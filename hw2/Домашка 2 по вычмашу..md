
# Введение

Из учебного курса мы узнали про регистры. Для того, чтобы освежить наши знания в памяти, давайте напомню длинное и скучное определение:

Регистр -  последовательное или параллельное логическое устройство, используемое для хранения n-разрядных двоичных чисел и выполнения преобразований над ними.

## **Основные виды регистров:**
- **Регистры общего назначения** — это **устройства сверхбыстродействующей памяти в процессоре**, предназначенные для временного хранения управляющей информации, операндов и/или результатов выполняемых операций. В них можно хранить информацию, которая должна быть всегда «под рукой».

- **Сегментные регистры** - хранят адреса сегментов программы, данных и стека.

- **Регистры состояния и управления** - хранят информацию о текущем состоянии процессора, результатах операций, а также контролируют выполнение инструкций. Туда входят счетчик команд ( хранит адрес выполняемой команды) и регистр состояний. Далее про состояния и флаги можно почитать под заголовком.



За полотном текста про назначение каждого регистра монжо пойти в интернет.
# Программа в памяти с модельной точки зрения выглядит как-то так
![f](картинки/1.png)

В каждом из этих сегментов хранятся данные определнного типа.
1) Сегмент программы включает в себя различные инструкции
2) Сегмент данных ранит глобальные переменные
3) Сегмент стека - ну это стек, в учебных материалах было)))

Все эти сегменты могут храниться в оперативной памяти в разных местах и в разной последовательности в зависимости от того, как решит операционная система. Мы можем использовать эти адреса для взаимодействия сегментов друг с другом. Все это и есть регистры. 

# Наконец-то информативный текст, ради которого мы все здесь собрались.

Программы при выполнении активно взаимодействуют с регистрами. По крайней мере, так нам пишут умные дяди в умных книжках. Давайте же на деле посмотрим, как меняются регистры процессора при выполнении простеньких программ на языке C.

Для демонстраации я буду использовать отладчик сишного кода gdb. Он умеет много всякого, в том числе позволяет в режиме реального времени отслеживать состояния регистра процессора (а также всех сегментов памяти, которыми пользуется программа)))

## Пример номер n

Рассмотрим простую программу `example.c` с выполнением обычных математических операций:
```C
#include <stdio.h>

int main(){
    int a = 10;
    int b = 12;

    int c = a + b;
    
    int meow = c * c;
    int meow_meow = meow * meow;
    int me_me = meow_meow / 2;
}
```

Для наших целей скомпилировать программу ее нужно с флагом `-g`, чтобы предоставить отладчику исходный код и далее запустить отладчик
```bash
mirkuriit@fedora:~/john_erikson$ gcc -g -o -example ./example.c
mirkuriit@fedora:~/john_erikson$ gdb -q ./example
Reading symbols from ./example...
(gdb) 
```
Попадаем в среду отладки и первым делом устанавливаем логирование всего, что мы собираемся делать:
```bash
(gdb) set logging enabled on
Copying output to gdb.txt.
Copying debug output to gdb.txt.
```
 Все результаты наших команд будут записываться в gdb.txt. Для просмотра состояния регистров мы можем использовать команду `info registers` но так как наша программа в данный момент не запущена в отладчике она не имеет доступ ни к каким регистрам.
 
```bash
(gdb) info registers
The program has no registers now.
```

Перед тем как запустить программу и посмотреть как меняются регистры установим точкe остановки программы в строке 4 с помощью команд break.

```bash
(gdb) break 4
Breakpoint 1 at 0x40110a: file example.c, line 4.
```

Теперь во время исполнения программа прервется на этой строке
![[Pasted image 20241030001142.png]]

Можем запустить программу, и снова попробовать посмотреть содеримое регистров:
```bash
(gdb) run 
...
Breakpoint 1, main () at example.c:4
warning: Source file is more recent than executable.
4           int a = 10;
(gdb) info registers
rax            0x401106            4198662
rbx            0x7fffffffdb58      140737488345944
rcx            0x403e40            4210240
rdx            0x7fffffffdb68      140737488345960
rsi            0x7fffffffdb58      140737488345944
rdi            0x1                 1
rbp            0x7fffffffda30      0x7fffffffda30
rsp            0x7fffffffda30      0x7fffffffda30
r8             0x0                 0
r9             0x7ffff7fcde90      140737353932432
r10            0x7fffffffd750      140737488344912
r11            0x203               515
r12            0x1                 1
r13            0x0                 0
r14            0x7ffff7ffd000      140737354125312
r15            0x403e40            4210240
rip            0x40110a            0x40110a <main+4>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7fac640      140737353795136
gs_base        0x0                 0
```
Видим много страшного текста. На самом деле команда info register показала нам значения, содержащиеся в регистрах в 16-ричных и 10-ричных системах счисления соотвественно. Из интересного:
r8-r15 - дополнительные регистры для хранения информации. eflags - флаги состояния процессора где:
- `PF` (Parity Flag): указывает на четность бита результата.
- `ZF` (Zero Flag): показывает, что результат последней операции был равен нулю.
- `IF` (Interrupt Flag): определяет возможность обработки прерываний.

Если в регистре находится например адрес памяти, то мы можем напрямую обратиться к этому адресу и посмотреть что там лежит с помощью команды x (от examine). Посмотрим, что лежит по адресу 0x401106 (это значение находится в регистре rax). В архитектуре x86-64 регистр `rax` используется не только для математических операций, но и для **возвращения значений из функций**.

```bash
(gdb) x 0x401106
0x401106 <main>:        0xe5894855
(gdb) x $rax
0x401106 <main>:        0xe5894855
```

- `<main>` — имя функции или метки, если адрес относится к коду, например, начальной инструкции функции `main`.
- `0xe5894855` — значение, хранящееся по этому адресу в памяти. Это **машинный код** инструкции, который процессор будет выполнять.

Идем далее. Команда next позволяет нам перейти к следующей строчке сишной программы. Снова вызываем info registers и обращаем внимание на изменение в регистре rip. Вспоминаем что rip - это так называемый **Instruction** **Pointer**. Он хранит в себе адрес выполняемой в данный момент команды. И хранит он его в виде смещения относительно начала функции main. 
```bash
rax            0x401106            4198662
...
# Видми <main+11> вместо <main+4>, который был на предыдущем выводе команды.
rip            0x401111            0x401111 <main+11>
...
gs_base        0x0                 0
```
Так как мы настраивали логирование, давайте пробежимся до конца прпограммы и посмотрим, в каких регистрах по ходу выполнения менялись адреса.

```bash 
(gdb) next
5           int b = 12;
(gdb) info registers
rax            0x401106            4198662
...
gs_base        0x0                 0
(gdb) next
7           int c = a + b;
(gdb) info registers
rax            0x401106            4198662
...
gs_base        0x0                 0
(gdb) next
8
(gdb) next
9           int meow = c * c;
(gdb) info registers
rax            0x1e4               484
...
gs_base        0x0                 0
(gdb) next
10          int meow_meow = meow * meow;
(gdb) next
(gdb) info registers
rax            0x0                 0
..
gs_base        0x0                 0
```

Полный вывод находится в логах gdb.txt. С помощью скрипта мы вытащим из него все наши состояния регистров в разной время и посмотрим что менялось во время выполнения программы.

```Python
import re

registers_pattern = r'rax[\s\S]*?gs_base.*'
breakpoints_pattern = r'(\d+)\s+breakpoint\s+keep\s+y\s+0x[0-9a-f]+ in main at example\.c:(\d+)'

def save_log(info_breakpoint, info_register, path):
    for i, el in zip(info_breakpoint, info_register):
        with open(path + f"{i}.txt", "w") as f:
            f.write(el)


with open("gdb.txt") as f:
    s = f.read()
    info_register = re.findall(registers_pattern, s)

save_log([str(i) for i in range(1, len(info_register))], info_register, "log1/")
```
в итоге получаем каталог с логами:
```bash
mirkuriit@fedora:~/log1$ ls
1.txt  2.txt  3.txt  4.txt  5.txt  6.txt
```

Проанализируем содержимое:
В момент выполения строк `int a = 10; ` и `int b=12;`лишь менялось содержимое регистра rip
```
mirkuriit@fedora:~/john_erikson/log1$ diff 1.txt 2.txt
17c17
< rip            0x40110a            0x40110a <main+4>
---
> rip            0x401111            0x401111 <main+11>
mirkuriit@fedora:~/john_erikson/log1$ diff 2.txt 3.txt
17c17
< rip            0x401111            0x401111 <main+11>
---
> rip            0x401118            0x401118 <main+18>
```

Дальше интереснее. После `int c = a + b;` замечаем большое количество изменений
```
mirkuriit@fedora:~/john_erikson/log1$ diff 3.txt 4.txt
1c1
< rax            0x401106            4198662
---
> rax            0x16                22
4c4
< rdx            0x7fffffffdb68      140737488345960
---
> rdx            0xa                 10
17,18c17,18
< rip            0x401118            0x401118 <main+18>
< eflags         0x246               [ PF ZF IF ]
---
> rip            0x401123            0x401123 <main+29>
> eflags         0x212               [ AF IF ]
```
- Во-первых, содержимое регистра rax с чего-то невразумительного поменялось на значение выражение a+b (10+12=22). rax=12.
- Во-вторых содержимое регистра rdx поменялось с чего-то невразумительного на 10. 10 -это промежуточное значение которое добавлялось в ходе операции сложения. Если в отладчике с помощью `disassemble /m main` посмотреть, что в этот момент происходит в ассемблере, можем увидеть следующее:
```bash
7           int c = a + b;
   0x0000000000401118 <+18>:    mov    edx,DWORD PTR [rbp-0x4]
   0x000000000040111b <+21>:    mov    eax,DWORD PTR [rbp-0x8]
   0x000000000040111e <+24>:    add    eax,edx
   0x0000000000401120 <+26>:    mov    DWORD PTR [rbp-0xc],eax
```

`mov edx, DWORD PTR [rbp-0x4]` -  помещает в регистр edx (rdx) 4 байта (тип `DWORD`) из памяти по адресу `rbp-0x4` (-4 байта отнсительно регистра rbp). Именно по этому адресу хранится переменная b.
Далее значение переменной а помещается в регистр eax (rax) и производится операция сложения.
Наконец, содержимое регистра eax (rax) копируется по адресу `rbp-0xc` (сохранение рзультата операции в c). 

- Также по традиции rip снова поменял свое значение.
- Также поменяли свои значения и регистры флагов. AF - так называемый Флаг вспомогательного переноса. Он устанавливается (в 1), если во время операции «сложения» происходит перенос из младшего полубайта (младшие четыре бита) в старший полубайт (старшие четыре бита) или заем из старшего полубайта в младший полубайт в младшей 8-битной части во время вычитания.

Идем далее:
После выполнения `int meow = c * c;` наблюдаем, что в регистре поменялось значение на резулоьтат текущей операции.
```
mirkuriit@fedora:~/john_erikson/log1$ diff 4.txt 5.txt
1c1
< rax            0x16                22
---
> rax            0x1e4               484
17c17
< rip            0x401123            0x401123 <main+29>
---
> rip            0x40112c            0x40112c <main+38>
```

Наконец, последняя информативная строка `int meow_meow = meow * meow;`
```
mirkuriit@fedora:~/john_erikson/log1$ diff 5.txt 6.txt
1c1
< rax            0x1e4               484
---
> rax            0x0                 0
17c17
< rip            0x40112c            0x40112c <main+38>
---
> rip            0x40113a            0x40113a <main+52>
```
Видим, что значение регистра поменялось с 484 на 0. Это странно, ведь До этого в регистр  rax записывался результат арифметической операции. Заглянем под капот произошедшего:

```bash
9           int meow = c * c;
   0x000000000040112c <+38>:    mov    eax,DWORD PTR [rbp-0x10]
   0x000000000040112f <+41>:    imul   eax,eax
   0x0000000000401132 <+44>:    mov    DWORD PTR [rbp-0x14],eax
   0x0000000000401135 <+47>:    mov    eax,0x0
```
В регистр eax (rax) копируется 4 байтовое значение расположенное по адресу `rbp-0x10`, происходит операция умножения, полученное занчение копируется из rax в ячейку `rbp-0x10`. Нконец, последним действием компилятор копирует в регистр rax значение 0. Это указывает на успешное завершение программы. 


# Выводы

В ходе исследования я на примере простой программы на С с помощью средств отладчика gdb в реальном времени пронаблюдал измение состояния регистров процессора и проанализировал причины этих изменений. Во время тестрования наглядно было показано, как выполнение математических операций меняет состояние регистров процессора и как команды, выполняемые на высокоуровневым языке С, соотносятся с машинными инструкциями на языке ассемблера. В ходе работы также был написан вспомогательный скрипт на python, позволяющий удобно сформировать набор файлов, содержащий состояния регистров при разных состояниях тестируемой программы. 















